

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>src.operations.segmentation package &mdash; Image Processing 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="src.panorama package" href="src.panorama.html" />
    <link rel="prev" title="src.operations.point package" href="src.operations.point.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Image Processing
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">python-image-processing</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="src.html">src package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="src.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="src.image.html">src.image package</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="src.operations.html">src.operations package</a></li>
<li class="toctree-l4"><a class="reference internal" href="src.panorama.html">src.panorama package</a></li>
<li class="toctree-l4"><a class="reference internal" href="src.widgets.html">src.widgets package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="src.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="src.html#module-src.constants">src.constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="src.html#module-src.main">src.main module</a></li>
<li class="toctree-l3"><a class="reference internal" href="src.html#module-src.main_ui">src.main_ui module</a></li>
<li class="toctree-l3"><a class="reference internal" href="src.html#module-src.style_sheet">src.style_sheet module</a></li>
<li class="toctree-l3"><a class="reference internal" href="src.html#module-src">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Image Processing</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">python-image-processing</a> &raquo;</li>
        
          <li><a href="src.html">src package</a> &raquo;</li>
        
          <li><a href="src.operations.html">src.operations package</a> &raquo;</li>
        
      <li>src.operations.segmentation package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/src.operations.segmentation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="src-operations-segmentation-package">
<h1>src.operations.segmentation package<a class="headerlink" href="#src-operations-segmentation-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-src.operations.segmentation.threshold">
<span id="src-operations-segmentation-threshold-module"></span><h2>src.operations.segmentation.threshold module<a class="headerlink" href="#module-src.operations.segmentation.threshold" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.Threshold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.threshold.</span></span><span class="sig-name descname"><span class="pre">Threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold.Threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PyQt5.QtWidgets.QDialog</span></code>, <a class="reference internal" href="src.operations.html#src.operations.operation.Operation" title="src.operations.operation.Operation"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.operations.operation.Operation</span></code></a>, <a class="reference internal" href="#src.operations.segmentation.threshold_ui.ThresholdUI" title="src.operations.segmentation.threshold_ui.ThresholdUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.operations.segmentation.threshold_ui.ThresholdUI</span></code></a></p>
<p>The Threshold class implements a thresholding point operation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.Threshold.calc_adaptive_thresh">
<span class="sig-name descname"><span class="pre">calc_adaptive_thresh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold.Threshold.calc_adaptive_thresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate adaptive threshold based on method and block size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>str</em>) – The method to perform, can be: “Mean” or “Gaussian”</p></li>
<li><p><strong>block_size</strong> (<em>int</em>) – The value for block size</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The new thresholded image data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>class:<cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.Threshold.calc_theshold_otsu">
<span class="sig-name descname"><span class="pre">calc_theshold_otsu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold.Threshold.calc_theshold_otsu" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Otsu’s thresholding.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.Threshold.calc_threshold_binary">
<span class="sig-name descname"><span class="pre">calc_threshold_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresh_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold.Threshold.calc_threshold_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate threshold binary point operation.</p>
<p>if the pixel is higher than <code class="xref py py-attr docutils literal notranslate"><span class="pre">thresh_value</span></code>,
then the new pixel intensity is set to a maximum
value - <code class="xref py py-attr docutils literal notranslate"><span class="pre">color_depth</span></code>-1.
Otherwise, the pixels are set to 0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>thresh_value</strong> (<em>int</em>) – The value for thresholding</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The new thresholded image data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>class:<cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.Threshold.calc_threshold_zero">
<span class="sig-name descname"><span class="pre">calc_threshold_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresh_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold.Threshold.calc_threshold_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate threshold to zero point operation.</p>
<p>If the pixel is lower than <code class="xref py py-attr docutils literal notranslate"><span class="pre">thresh_value</span></code>,
the new pixel value will be set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>thresh_value</strong> (<em>int</em>) – The value for thresholding</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The new thresholded image data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>class:<cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.Threshold.update_form">
<span class="sig-name descname"><span class="pre">update_form</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold.Threshold.update_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the slider behavior and slider text based on threshold type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.Threshold.update_img_preview">
<span class="sig-name descname"><span class="pre">update_img_preview</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold.Threshold.update_img_preview" title="Permalink to this definition">¶</a></dt>
<dd><p>Update image preview window.</p>
<ul class="simple">
<li><p>Calculate image thresholding based on type and slider value.</p></li>
<li><p>Reload image preview using the base <code class="xref py py-class docutils literal notranslate"><span class="pre">operation.Operation</span></code> method.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.Threshold.update_slider_value">
<span class="sig-name descname"><span class="pre">update_slider_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold.Threshold.update_slider_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <code class="xref py py-attr docutils literal notranslate"><span class="pre">label_slider_value</span></code> whenever is changed.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.adaptiveThreshold">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.threshold.</span></span><span class="sig-name descname"><span class="pre">adaptiveThreshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">maxValue</span></em>, <em class="sig-param"><span class="pre">adaptiveMethod</span></em>, <em class="sig-param"><span class="pre">thresholdType</span></em>, <em class="sig-param"><span class="pre">blockSize</span></em>, <em class="sig-param"><span class="pre">C</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.threshold.adaptiveThreshold" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Applies an adaptive threshold to an array.
.   
.   The function transforms a grayscale image to a binary image according to the formulae:
.   -   <strong>THRESH_BINARY</strong>
.       f[dst(x,y) =  fork{texttt{maxValue}}{if (src(x,y) &gt; T(x,y))}{0}{otherwise}f]
.   -   <strong>THRESH_BINARY_INV</strong>
.       f[dst(x,y) =  fork{0}{if (src(x,y) &gt; T(x,y))}{texttt{maxValue}}{otherwise}f]
.   where f$T(x,y)f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).
.   
.   The function can process the image in-place.
.   
.   &#64;param src Source 8-bit single-channel image.
.   &#64;param dst Destination image of the same size and the same type as src.
.   &#64;param maxValue Non-zero value assigned to the pixels for which the condition is satisfied
.   &#64;param adaptiveMethod Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes.
.   The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries.
.   &#64;param thresholdType Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV,
.   see #ThresholdTypes.
.   &#64;param blockSize Size of a pixel neighborhood that is used to calculate a threshold value for the
.   pixel: 3, 5, 7, and so on.
.   &#64;param C Constant subtracted from the mean or weighted mean (see the details below). Normally, it
.   is positive but may be zero or negative as well.
.   
.   &#64;sa  threshold, blur, GaussianBlur</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.normalize">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.threshold.</span></span><span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">alpha</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">beta</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">norm_type</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dtype</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">mask</span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.threshold.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Normalizes the norm or value range of an array.
.   
.   The function cv::normalize normalizes scale and shift the input array elements so that
.   f[| texttt{dst} | _{L_p}= texttt{alpha}f]
.   (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
.   f[min _I  texttt{dst} (I)= texttt{alpha} , , , max _I  texttt{dst} (I)= texttt{beta}f]
.   
.   when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
.   normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
.   sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
.   min-max but modify the whole array, you can use norm and Mat::convertTo.
.   
.   In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
.   the range transformation for sparse matrices is not allowed since it can shift the zero level.
.   
.   Possible usage with some positive example data:
.   &#64;code{.cpp}
.       vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 };
.       vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;
.   
.       // Norm to probability (total count)
.       // sum(numbers) = 20.0
.       // 2.0      0.1     (2.0/20.0)
.       // 8.0      0.4     (8.0/20.0)
.       // 10.0     0.5     (10.0/20.0)
.       normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);
.   
.       // Norm to unit vector: ||positiveData|| = 1.0
.       // 2.0      0.15
.       // 8.0      0.62
.       // 10.0     0.77
.       normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);
.   
.       // Norm to max element
.       // 2.0      0.2     (2.0/10.0)
.       // 8.0      0.8     (8.0/10.0)
.       // 10.0     1.0     (10.0/10.0)
.       normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);
.   
.       // Norm to range [0.0;1.0]
.       // 2.0      0.0     (shift to left border)
.       // 8.0      0.75    (6.0/8.0)
.       // 10.0     1.0     (shift to right border)
.       normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
.   &#64;endcode
.   
.   &#64;param src input array.
.   &#64;param dst output array of the same size as src .
.   &#64;param alpha norm value to normalize to or the lower range boundary in case of the range
.   normalization.
.   &#64;param beta upper range boundary in case of the range normalization; it is not used for the norm
.   normalization.
.   &#64;param norm_type normalization type (see cv::NormTypes).
.   &#64;param dtype when negative, the output array has the same type as src; otherwise, it has the same
.   number of channels as src and the depth =CV_MAT_DEPTH(dtype).
.   &#64;param mask optional operation mask.
.   &#64;sa norm, Mat::convertTo, SparseMat::convertTo</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold.threshold">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.threshold.</span></span><span class="sig-name descname"><span class="pre">threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">thresh</span></em>, <em class="sig-param"><span class="pre">maxval</span></em>, <em class="sig-param"><span class="pre">type</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">retval</span><span class="p"><span class="pre">,</span> </span><span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.threshold.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Applies a fixed-level threshold to each array element.
.   
.   The function applies fixed-level thresholding to a multiple-channel array. The function is typically
.   used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for
.   this purpose) or for removing a noise, that is, filtering out pixels with too small or too large
.   values. There are several types of thresholding supported by the function. They are determined by
.   type parameter.
.   
.   Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the
.   above values. In these cases, the function determines the optimal threshold value using the Otsu’s
.   or Triangle algorithm and uses it instead of the specified thresh.
.   
.   &#64;note Currently, the Otsu’s and Triangle methods are implemented only for 8-bit single-channel images.
.   
.   &#64;param src input array (multiple-channel, 8-bit or 32-bit floating point).
.   &#64;param dst output array of the same size  and type and the same number of channels as src.
.   &#64;param thresh threshold value.
.   &#64;param maxval maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding
.   types.
.   &#64;param type thresholding type (see #ThresholdTypes).
.   &#64;return the computed threshold value if Otsu’s or Triangle methods used.
.   
.   &#64;sa  adaptiveThreshold, findContours, compare, min, max</p>
</dd></dl>

</div>
<div class="section" id="module-src.operations.segmentation.threshold_ui">
<span id="src-operations-segmentation-threshold-ui-module"></span><h2>src.operations.segmentation.threshold_ui module<a class="headerlink" href="#module-src.operations.segmentation.threshold_ui" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold_ui.ThresholdUI">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.threshold_ui.</span></span><span class="sig-name descname"><span class="pre">ThresholdUI</span></span><a class="headerlink" href="#src.operations.segmentation.threshold_ui.ThresholdUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="src.operations.html#src.operations.operation_ui.OperationUI" title="src.operations.operation_ui.OperationUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.operations.operation_ui.OperationUI</span></code></a>, <a class="reference internal" href="src.operations.html#src.operations.form_ui.FormUI" title="src.operations.form_ui.FormUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.operations.form_ui.FormUI</span></code></a></p>
<p>Build UI for <code class="xref py py-class docutils literal notranslate"><span class="pre">threshold.Threshold</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.threshold_ui.ThresholdUI.init_ui">
<span class="sig-name descname"><span class="pre">init_ui</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.threshold_ui.ThresholdUI.init_ui" title="Permalink to this definition">¶</a></dt>
<dd><p>Create user interface for <code class="xref py py-class docutils literal notranslate"><span class="pre">threshold.Threshold</span></code>.</p>
<p>The method creates the widget objects in the proper containers
and assigns the object names to them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>threshold</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">threshold.Threshold</span></code>) – The dialog threshold window</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.operations.segmentation.watershed">
<span id="src-operations-segmentation-watershed-module"></span><h2>src.operations.segmentation.watershed module<a class="headerlink" href="#module-src.operations.segmentation.watershed" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.Watershed">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">Watershed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.watershed.Watershed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PyQt5.QtWidgets.QDialog</span></code>, <a class="reference internal" href="src.operations.html#src.operations.operation.Operation" title="src.operations.operation.Operation"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.operations.operation.Operation</span></code></a>, <a class="reference internal" href="#src.operations.segmentation.watershed_ui.WatershedUI" title="src.operations.segmentation.watershed_ui.WatershedUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.operations.segmentation.watershed_ui.WatershedUI</span></code></a></p>
<p>The Watershed class implements a watershed segmentation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.Watershed.calc_watershed">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">calc_watershed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img_color</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.watershed.Watershed.calc_watershed" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate watershed segmentation with different previews.</p>
<dl class="simple">
<dt>There are 4 previews of segmented objects:</dt><dd><ul class="simple">
<li><p>Color image.</p></li>
<li><p>Grayscale image.</p></li>
<li><p>Pseudocolor.</p></li>
<li><p>Blended.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>img_color</strong> (class:<cite>numpy.ndarray</cite>) – The image data to perform watershed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The pair: objects count and dictionary with available previews</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[int, dict]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.Watershed.update_img_preview">
<span class="sig-name descname"><span class="pre">update_img_preview</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.watershed.Watershed.update_img_preview" title="Permalink to this definition">¶</a></dt>
<dd><p>Update image preview window.</p>
<ul class="simple">
<li><p>Select image preview based on chosen preview.</p></li>
<li><p>Reload image preview using the base <code class="xref py py-class docutils literal notranslate"><span class="pre">operation.Operation</span></code> method.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.addWeighted">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">addWeighted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src1</span></em>, <em class="sig-param"><span class="pre">alpha</span></em>, <em class="sig-param"><span class="pre">src2</span></em>, <em class="sig-param"><span class="pre">beta</span></em>, <em class="sig-param"><span class="pre">gamma</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dtype</span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.watershed.addWeighted" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Calculates the weighted sum of two arrays.
.   
.   The function addWeighted calculates the weighted sum of two arrays as follows:
.   f[texttt{dst} (I)= texttt{saturate} ( texttt{src1} (I)* texttt{alpha} +  texttt{src2} (I)* texttt{beta} +  texttt{gamma} )f]
.   where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
.   channel is processed independently.
.   The function can be replaced with a matrix expression:
.   &#64;code{.cpp}
.       dst = src1*alpha + src2*beta + gamma;
.   &#64;endcode
.   &#64;note Saturation is not applied when the output array has the depth CV_32S. You may even get
.   result of an incorrect sign in the case of overflow.
.   &#64;param src1 first input array.
.   &#64;param alpha weight of the first array elements.
.   &#64;param src2 second input array of the same size and channel number as src1.
.   &#64;param beta weight of the second array elements.
.   &#64;param gamma scalar added to each sum.
.   &#64;param dst output array that has the same size and number of channels as the input arrays.
.   &#64;param dtype optional depth of the output array; when both input arrays have the same depth, dtype
.   can be set to -1, which will be equivalent to src1.depth().
.   &#64;sa  add, subtract, scaleAdd, Mat::convertTo</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.applyColorMap">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">applyColorMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">colormap</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.watershed.applyColorMap" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Applies a GNU Octave/MATLAB equivalent colormap on a given image.
.   
.   &#64;param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.
.   &#64;param dst The result is the colormapped source image. Note: Mat::create is called on dst.
.   &#64;param colormap The colormap to apply, see #ColormapTypes</p>
<p>applyColorMap(src, userColor[, dst]) -&gt; dst
.   &#64;brief Applies a user colormap on a given image.
.   
.   &#64;param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.
.   &#64;param dst The result is the colormapped source image. Note: Mat::create is called on dst.
.   &#64;param userColor The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.connectedComponents">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">connectedComponents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">image</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">labels</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">connectivity</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">ltype</span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">retval</span><span class="p"><span class="pre">,</span> </span><span class="pre">labels</span><a class="headerlink" href="#src.operations.segmentation.watershed.connectedComponents" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;overload
.   
.   &#64;param image the 8-bit single-channel image to be labeled
.   &#64;param labels destination labeled image
.   &#64;param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
.   &#64;param ltype output image label type. Currently CV_32S and CV_16U are supported.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.cvtColor">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">cvtColor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">code</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dstCn</span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.watershed.cvtColor" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Converts an image from one color space to another.
.   
.   The function converts an input image from one color space to another. In case of a transformation
.   to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
.   that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the
.   bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
.   component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
.   sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.
.   
.   The conventional ranges for R, G, and B channel values are:
.   -   0 to 255 for CV_8U images
.   -   0 to 65535 for CV_16U images
.   -   0 to 1 for CV_32F images
.   
.   In case of linear transformations, the range does not matter. But in case of a non-linear
.   transformation, an input RGB image should be normalized to the proper value range to get the correct
.   results, for example, for RGB f$rightarrowf$ L*u*v* transformation. For example, if you have a
.   32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will
.   have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor ,
.   you need first to scale the image down:
.   &#64;code
.       img <a href="#id1"><span class="problematic" id="id2">*</span></a>= 1./255;
.       cvtColor(img, img, COLOR_BGR2Luv);
.   &#64;endcode
.   If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many
.   applications, this will not be noticeable but it is recommended to use 32-bit images in applications
.   that need the full range of colors or that convert an image before an operation and then convert
.   back.
.   
.   If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
.   range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.
.   
.   &#64;param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC… ), or single-precision
.   floating-point.
.   &#64;param dst output image of the same size and depth as src.
.   &#64;param code color space conversion code (see #ColorConversionCodes).
.   &#64;param dstCn number of channels in the destination image; if the parameter is 0, the number of the
.   channels is derived automatically from src and code.
.   
.   &#64;see &#64;ref imgproc_color_conversions</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.distanceTransform">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">distanceTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">distanceType</span></em>, <em class="sig-param"><span class="pre">maskSize</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dstType</span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.watershed.distanceTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;overload
.   &#64;param src 8-bit, single-channel (binary) source image.
.   &#64;param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
.   single-channel image of the same size as src .
.   &#64;param distanceType Type of distance, see #DistanceTypes
.   &#64;param maskSize Size of the distance transform mask, see #DistanceTransformMasks. In case of the
.   #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a f$3times 3f$ mask gives
.   the same result as f$5times 5f$ or any larger aperture.
.   &#64;param dstType Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for
.   the first variant of the function and distanceType == #DIST_L1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.morphologyEx">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">morphologyEx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">op</span></em>, <em class="sig-param"><span class="pre">kernel</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">anchor</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">iterations</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">borderType</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">borderValue</span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.watershed.morphologyEx" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Performs advanced morphological transformations.
.   
.   The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
.   basic operations.
.   
.   Any of the operations can be done in-place. In case of multi-channel images, each channel is
.   processed independently.
.   
.   &#64;param src Source image. The number of channels can be arbitrary. The depth should be one of
.   CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
.   &#64;param dst Destination image of the same size and type as source image.
.   &#64;param op Type of a morphological operation, see #MorphTypes
.   &#64;param kernel Structuring element. It can be created using #getStructuringElement.
.   &#64;param anchor Anchor position with the kernel. Negative values mean that the anchor is at the
.   kernel center.
.   &#64;param iterations Number of times erosion and dilation are applied.
.   &#64;param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
.   &#64;param borderValue Border value in case of a constant border. The default value has a special
.   meaning.
.   &#64;sa  dilate, erode, getStructuringElement
.   &#64;note The number of iterations is the number of times erosion or dilatation operation will be applied.
.   For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
.   successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.subtract">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">subtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src1</span></em>, <em class="sig-param"><span class="pre">src2</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">mask</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dtype</span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.watershed.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Calculates the per-element difference between two arrays or array and a scalar.
.   
.   The function subtract calculates:
.   - Difference between two arrays, when both input arrays have the same size and the same number of
.   channels:
.       f[texttt{dst}(I) =  texttt{saturate} ( texttt{src1}(I) -  texttt{src2}(I)) quad texttt{if mask}(I) ne0f]
.   - Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
.   number of elements as <cite>src1.channels()</cite>:
.       f[texttt{dst}(I) =  texttt{saturate} ( texttt{src1}(I) -  texttt{src2} ) quad texttt{if mask}(I) ne0f]
.   - Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
.   number of elements as <cite>src2.channels()</cite>:
.       f[texttt{dst}(I) =  texttt{saturate} ( texttt{src1} -  texttt{src2}(I) ) quad texttt{if mask}(I) ne0f]
.   - The reverse difference between a scalar and an array in the case of <cite>SubRS</cite>:
.       f[texttt{dst}(I) =  texttt{saturate} ( texttt{src2} -  texttt{src1}(I) ) quad texttt{if mask}(I) ne0f]
.   where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
.   channel is processed independently.
.   
.   The first function in the list above can be replaced with matrix expressions:
.   &#64;code{.cpp}
.       dst = src1 - src2;
.       dst -= src1; // equivalent to subtract(dst, src1, dst);
.   &#64;endcode
.   The input arrays and the output array can all have the same or different depths. For example, you
.   can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
.   the output array is determined by dtype parameter. In the second and third cases above, as well as
.   in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
.   case the output array will have the same depth as the input array, be it src1, src2 or both.
.   &#64;note Saturation is not applied when the output array has the depth CV_32S. You may even get
.   result of an incorrect sign in the case of overflow.
.   &#64;param src1 first input array or a scalar.
.   &#64;param src2 second input array or a scalar.
.   &#64;param dst output array of the same size and the same number of channels as the input array.
.   &#64;param mask optional operation mask; this is an 8-bit single channel array that specifies elements
.   of the output array to be changed.
.   &#64;param dtype optional depth of the output array
.   &#64;sa  add, addWeighted, scaleAdd, Mat::convertTo</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.threshold">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">thresh</span></em>, <em class="sig-param"><span class="pre">maxval</span></em>, <em class="sig-param"><span class="pre">type</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">dst</span></em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; <span class="pre">retval</span><span class="p"><span class="pre">,</span> </span><span class="pre">dst</span><a class="headerlink" href="#src.operations.segmentation.watershed.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Applies a fixed-level threshold to each array element.
.   
.   The function applies fixed-level thresholding to a multiple-channel array. The function is typically
.   used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for
.   this purpose) or for removing a noise, that is, filtering out pixels with too small or too large
.   values. There are several types of thresholding supported by the function. They are determined by
.   type parameter.
.   
.   Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the
.   above values. In these cases, the function determines the optimal threshold value using the Otsu’s
.   or Triangle algorithm and uses it instead of the specified thresh.
.   
.   &#64;note Currently, the Otsu’s and Triangle methods are implemented only for 8-bit single-channel images.
.   
.   &#64;param src input array (multiple-channel, 8-bit or 32-bit floating point).
.   &#64;param dst output array of the same size  and type and the same number of channels as src.
.   &#64;param thresh threshold value.
.   &#64;param maxval maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding
.   types.
.   &#64;param type thresholding type (see #ThresholdTypes).
.   &#64;return the computed threshold value if Otsu’s or Triangle methods used.
.   
.   &#64;sa  adaptiveThreshold, findContours, compare, min, max</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed.watershed">
<span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed.</span></span><span class="sig-name descname"><span class="pre">watershed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markers</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">markers</span><a class="headerlink" href="#src.operations.segmentation.watershed.watershed" title="Permalink to this definition">¶</a></dt>
<dd><p>.   &#64;brief Performs a marker-based image segmentation using the watershed algorithm.
.   
.   The function implements one of the variants of watershed, non-parametric marker-based segmentation
.   algorithm, described in &#64;cite Meyer92 .
.   
.   Before passing the image to the function, you have to roughly outline the desired regions in the
.   image markers with positive (&gt;0) indices. So, every region is represented as one or more connected
.   components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary
.   mask using #findContours and #drawContours (see the watershed.cpp demo). The markers are “seeds” of
.   the future image regions. All the other pixels in markers , whose relation to the outlined regions
.   is not known and should be defined by the algorithm, should be set to 0’s. In the function output,
.   each pixel in markers is set to a value of the “seed” components or to -1 at boundaries between the
.   regions.
.   
.   &#64;note Any two neighbor connected components are not necessarily separated by a watershed boundary
.   (-1’s pixels); for example, they can touch each other in the initial marker image passed to the
.   function.
.   
.   &#64;param image Input 8-bit 3-channel image.
.   &#64;param markers Input/output 32-bit single-channel image (map) of markers. It should have the same
.   size as image .
.   
.   &#64;sa findContours
.   
.   &#64;ingroup imgproc_misc</p>
</dd></dl>

</div>
<div class="section" id="module-src.operations.segmentation.watershed_ui">
<span id="src-operations-segmentation-watershed-ui-module"></span><h2>src.operations.segmentation.watershed_ui module<a class="headerlink" href="#module-src.operations.segmentation.watershed_ui" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed_ui.WatershedUI">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">src.operations.segmentation.watershed_ui.</span></span><span class="sig-name descname"><span class="pre">WatershedUI</span></span><a class="headerlink" href="#src.operations.segmentation.watershed_ui.WatershedUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="src.operations.html#src.operations.operation_ui.OperationUI" title="src.operations.operation_ui.OperationUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.operations.operation_ui.OperationUI</span></code></a>, <a class="reference internal" href="src.operations.html#src.operations.form_ui.FormUI" title="src.operations.form_ui.FormUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.operations.form_ui.FormUI</span></code></a></p>
<p>Build UI for <code class="xref py py-class docutils literal notranslate"><span class="pre">watershed.Watershed</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.operations.segmentation.watershed_ui.WatershedUI.init_ui">
<span class="sig-name descname"><span class="pre">init_ui</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">watershed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operations.segmentation.watershed_ui.WatershedUI.init_ui" title="Permalink to this definition">¶</a></dt>
<dd><p>Create user interface for <code class="xref py py-class docutils literal notranslate"><span class="pre">watershed.Watershed</span></code>.</p>
<p>The method creates the widget objects in the proper containers
and assigns the object names to them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>watershed</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">watershed.Watershed</span></code>) – The dialog watershed window</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.operations.segmentation">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-src.operations.segmentation" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="src.panorama.html" class="btn btn-neutral float-right" title="src.panorama package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="src.operations.point.html" class="btn btn-neutral float-left" title="src.operations.point package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Vadym Mariiechko.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>